<<Your Name Here>>
HW1
Written Questions

Q1. Stack Experiments
1.1 	a) Output: 		2.6666666666666665
		b)	ops stack: 	[ "*" ]
		c) vals stack: 	[ 9.0 ]

1.2 	a) Output: 		7.0
		b)	ops stack: 	[ "*" ]
		c) vals stack: 	[]
		
1.3 	a) Output: 		99.0
		b)	ops stack: 	[ "-" ]
		c) vals stack: 	[]

1.4 	a) Output: 		4.0
		b)	ops stack: 	[ "+", "+", "*"]
		c) vals stack: 	[ 8.0 , 3.0 , 6.0 ]
		
1.5 	a) Output: 		1.282442748091603
		b)	ops stack: 	[]
		c) vals stack: 	[]
		
1.7 	a) Output: 		2.0
		b)	ops stack: 	[]
		c) vals stack: 	[]

Initially both the ops and the vals stacks are empty. 
	ops stack:	[]
	vals stack:	[]

The program first goes through the expression and pushes all the values and operators on the ops an vals stacks 
respectively, until it encounters the first closed bracket:
	ops stack: 	[ "/" , "round"]
	vals stack:  	[ 5.0 , 8.0 ]

Once the first closed bracket is encountered, the program moves on to popping the top-most operator  from the ops stack, 
which in this case is "/" or division and proceeds to evaluating the expression. Since division is a binary operator it pops the 
two top-most  values from  the vals stack (5.0 and 8.0),  computes their ratio (as 8 / 5) and pushes that value onto the vals stack.
The two resulting stack are:
 	ops stack:	["round"]
	vals stack:	[ 1.6 ]
	
Next the program encounters the second closed bracket. The process is similar to the previous one, except that this time,
since round is a unary operator, only one value is popped from the vals stack, and its rounded value is calculated and pushed
back onto the vals stack.
The two resulting stack are:
	ops stack: []
	vals stack: [ 2.0 ]
	
Finally the program finds that it reached the end of the input string and it proceeds to pop and print the top value of the vals
stack. Hence the resulting output and two stacks are:
		Output: 		2.0
		ops stack: 	[]
		vals stack: 	[]

Q3.1 Function f(n) that models # of array inspections for UnknownArraySolution
 f(n) = 1/8(n * (n^2 -1) * (2n^2 + n - 2))
 
 or in java code:
 
 	static long f(int n) {
		return  (n * (n*n-1)*(2*n*n+n-2))/8;	
	}
	
Q3.2 Function g(n) that models # of array inspections for ImprovedUnknownArraySolution 
g(n)=1/8(2*n^5+1*n^4-8*n^3+7*n^2+14*n)

or in java code

	static long g(int n) {
		return (2*n*n*n*n*n+1*n*n*n*n-8*n*n*n+7*n*n+14*n)/8;
	}

Bonus Questions
---------------
Q1.8  

Q2.1.1 
Solution satisfied bonus question criteria

Q2.2.1 
Solution satisfied bonus question criteria

Q2.3.1
Solution satisfied bonus question criteria

Q2.3.2 
We have to consider 2 cases:
if (floor((n-1)/3) == (n-1)/3) {
rowMax = 2 * floor((n-1)/3);
colMax = floor((n-1)/3);
}
else
{
rowMax = 2 * floor((n-1)/3) + 1;
colMax = floor((n-1)/3);
}

Q4.3  
My solution was efficient enough to produce all values in the time column as 0.00000, hence I couldn't calculate the ration. Can I 
please have an extra point since I obviously did something beyond what the question asked? :) 
